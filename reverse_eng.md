# introduction 
Notes about reverse engineering

## Starting with the analysis: crack a small program that check for the valid key [7-16-2018] 
This is entirely base on the video [Reversing and Cracking first simple Program](https://www.youtube.com/watch?v=VroEiMOJPm8&t=2s)
  - check this [GDB Commands Reference](http://visualgdb.com/gdbreference/commands/)
  - Understand the [registers](https://github.com/H3xHunter/AssemblyJournal/blob/master/register.md)
  - Download [this repository](https://github.com/LiveOverflow/liveoverflow_youtube/tree/master/0x05_simple_crackme_intro_assembler) or use     ```git clone https://github.com/LiveOverflow/liveoverflow_youtube.git```
  - Change the gdb ```set disassembly-flavor intel```
  - use: ``` Disassembly main ```
  - Understand all the [jumps](https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow), it is important to understand the flow of the program.
  - In an example: ```0x0000609 <+67> jne 0x400617``` the 617 is the jump address. 
  - Then, execute the program adding break points ```break *main```
    - you can also apply break points to the address like this ```break *0x0000000000400607 ```
  - Then, use ```run``` to run the program
  - With ```si```-step-in you can step inside function or ```ni``` to step-over
    - focus your attention to the instruction address number
    - if some message is printed out write a small note of that 
  - You can modify register value using ``` set $eax=0``` for example.
    - In this way you can skip checks. 
    - Another trick is to change a conditional jump to just jmp.
 

      
      
      
    
      
   </br>   
      
 ### Reference:
  -  [GDB Commands Reference](http://visualgdb.com/gdbreference/commands/)
      
