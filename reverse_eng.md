# introduction 
Notes about reverse engineering subdirectory of [this](https://github.com/H3xHunter/PedanticMalwareAnalysisJournal/blob/master/july.md) journal.

## Analysis Fundamentals:
### [7-16-2018]  Starting with the analysis: crack a small program that check for the valid key 
This is entirely base on the video [Reversing and Cracking first simple Program](https://www.youtube.com/watch?v=VroEiMOJPm8&t=2s)
  - check this [GDB Commands Reference](http://visualgdb.com/gdbreference/commands/)
  - Understand the [registers](https://github.com/H3xHunter/AssemblyJournal/blob/master/register.md)
  - Download [this repository](https://github.com/LiveOverflow/liveoverflow_youtube/tree/master/0x05_simple_crackme_intro_assembler) or use     ```git clone https://github.com/LiveOverflow/liveoverflow_youtube.git```
  - Change the gdb ```set disassembly-flavor intel```
  - use: ``` Disassembly main ```
  - Understand all the [jumps](https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow), it is important to understand the flow of the program.
  - In an example: ```0x0000609 <+67> jne 0x400617``` the 617 is the jump address. 
  - Then, execute the program adding break points ```break *main```
    - you can also apply break points to the address like this ```break *0x0000000000400607 ```
  - Then, use ```run``` to run the program
  - With ```si```-step-in you can step inside function or ```ni``` to step-over
    - focus your attention to the instruction address number
    - if some message is printed out write a small note of that 
  - You can modify register value using ``` set $eax=0``` for example.
    - In this way you can skip checks. 
    - Another trick is to change a conditional jump to just jmp.
    
#### Conclusion:
After checking the jumps and have a good idea of the program structure, you can understand how the program works. Therefore, you can proceed to hardcode a value in the registry or change the check-conditions. Nb: because I checked other videos, I am well aware that this is not always the case or not that straight forward. But for now, it is enough for me to understand the basics how to crack small simple program like in the video. 
      
     
### [7-18-2018] Reversing binary with basic tools
This is entirely base on the video [Reversing and Cracking first simple Program](https://www.youtube.com/watch?v=VroEiMOJPm8&t=2s)
- strings
- file
- objdump
- hexdump
  - ```objdump -d -M intel <input file name> > dump.asm```
- radare2

#### file
file tests each argument in an attempt to classify it. There are three sets of tests, performed in this order: filesystem tests, magic tests, and language tests. The first test that succeeds causes the file type to be printed.
Usage:
  - ```file *fileName*```

#### strings
For each file given, GNU strings prints the printable character sequences that are at least 4 characters long (or the number given with the options below) and are followed by an unprintable character. By default, it only prints the strings from the initialized and loaded sections of object files; for other types of files, it prints the strings from the whole file.
Usage:
  -    ```strings [-afovV] [-min-len] [-n min-len] [--bytes=min-len] [-t radix] [--radix=radix] [-e encoding] [--encoding=encoding] [-] [--all] [--print-file-name] [-T bfdname] [--target=bfdname] [--help] [--version] file```
  - ``` strings *fileName* | grep *something* ```
      
#### hexdump      
The hexdump utility is a filter which displays the specified files, or the standard input, if no files are specified, in a user specified format.
- ```hexdump [-bcCdovx] [-e format_string] [-f format_file] [-n length] [-s skip] file ... ```

#### objdump
objdump displays information about one or more object files. The options control what particular information to display. This information is mostly useful to programmers who are working on the compilation tools, as opposed to programmers who just want their program to compile and work.
Usage:
- [Link](https://linux.die.net/man/1/objdump)
```objdump [-a|--archive-headers]
        [-b bfdname|--target=bfdname]
        [-C|--demangle[=style] ]
        [-d|--disassemble]
        [-D|--disassemble-all]
        [-z|--disassemble-zeroes]
        [-EB|-EL|--endian={big | little }]
        [-f|--file-headers]
        [--file-start-context]
        [-g|--debugging]
        [-h|--section-headers|--headers]
        [-i|--info]
        [-j section|--section=section]
        [-l|--line-numbers]
        [-S|--source]
        [-m machine|--architecture=machine]
        [-M options|--disassembler-options=options]
        [-p|--private-headers]
        [-r|--reloc]
        [-R|--dynamic-reloc]
        [-s|--full-contents]
        [-G|--stabs]
        [-t|--syms]
        [-T|--dynamic-syms]
        [-x|--all-headers]
        [-w|--wide]
        [--start-address=address]
        [--stop-address=address]
        [--prefix-addresses]
        [--[no-]show-raw-insn]
        [--adjust-vma=offset]
        [-V|--version]
        [-H|--help]
```
#### Radara2
Radare is an open source reversing framework. It comes with a ton of options, functionality, and a somewhat daunting learning curve. I primarily use it for CTF challenges, and I love that I can run it on a terminal along side GDB without requiring a GUI.
A full set of commands [here](https://github.com/radare/radare2/blob/master/doc/intro.md).
```
git clone github.com/radare/radare2.git
./sys/install.sh
```
   </br>   
      
 ### Reference:
  -  [GDB Commands Reference](http://visualgdb.com/gdbreference/commands/)
      
