# Analysis Fundamentals

### [7-16-2018]  Reversing and Cracking first simple Program - bin 0x05
This is entirely base on the video [Reversing and Cracking first simple Program](https://www.youtube.com/watch?v=VroEiMOJPm8&t=2s)
  - check this [GDB Commands Reference](http://visualgdb.com/gdbreference/commands/)
  - Understand the [registers](https://github.com/H3xHunter/AssemblyJournal/blob/master/register.md)
  - Download [this repository](https://github.com/LiveOverflow/liveoverflow_youtube/tree/master/0x05_simple_crackme_intro_assembler) or use     ```git clone https://github.com/LiveOverflow/liveoverflow_youtube.git```
  - Change the gdb ```set disassembly-flavor intel```
  - use: ``` Disassembly main ```
  - Understand all the [jumps](https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow), it is important to understand the flow of the program.
  - In an example: ```0x0000609 <+67> jne 0x400617``` the 617 is the jump address. 
  - Then, execute the program adding break points ```break *main```
    - you can also apply break points to the address like this ```break *0x0000000000400607 ```
  - Then, use ```run``` to run the program
  - With ```si```-step-in you can step inside function or ```ni``` to step-over
    - focus your attention to the instruction address number
    - if some message is printed out write a small note of that 
  - You can modify register value using ``` set $eax=0``` for example.
    - In this way you can skip checks. 
    - Another trick is to change a conditional jump to just jmp.
    
#### Summary:
After checking the jumps and have a good idea of the program structure, you can understand how the program works. Therefore, you can proceed to hardcode a value in the registry or change the check-conditions. Nb: because I checked other videos, I am well aware that this is not always the case or not that straight forward. But for now, it is enough for me to understand the basics how to crack small simple program like in the video. 
      
     
### [7-18-2018] Simple Tools and Techniques for Reversing a binary - bin 0x06
This is entirely base on the video [Reversing and Cracking first simple Program](https://www.youtube.com/watch?v=VroEiMOJPm8&t=2s)
- strings
   - ``` strings *fileName* | grep *fileName*```
- file
  - ```file  *fileName*```
- objdump
  - ```objdump -d -M intel *fileName* > dump.asm | grep j```
- hexdump
  - ``` hexdump -C *fileName* ```
- xxd
  - ``` xxd *fineName* | less ```
- radare2
  - ```r2 -d  *fileName* ```     

#### Radara2
Radare is an open source reversing framework. It comes with a ton of options, functionality, and a somewhat daunting learning curve. I primarily use it for CTF challenges, and I love that I can run it on a terminal along side GDB without requiring a GUI.
A full set of commands [here](https://github.com/radare/radare2/blob/master/doc/intro.md).
- ```
git clone github.com/radare/radare2.git
./sys/install.sh
```
Usage:
- ```
r2 -d *fileName*
   aaa - automaticaly analyze all
   afl - print all functions
   s main - change location
   pdf - print disassembly current fucntion
   VV or V! - visual mode
      - shift-tab           | change main tab
      - shift-r             | change theme
      - shift-s             | step over function
      - p change visual     |
      - ? help              |
      - arrows move around  |
      - :                   | input commands eg: dc

```
Basic workflow:
```
r2 -d *fileName*
  - aaa
  - s main
  - pdf
  - :
  - db <break point>
  - dc 
  - shift-s
```

   </br>   
   
   
#### The key generator
In the second video, instead of hardcoding the value of the key the the author of the video produce a simple algorithm that sumup the ascii value to an int sum variable. The available solutions are always to patch the jump, but it is possible to code a keygenerator in python and bruteforce the solution or in this case the solutions, yes because there are multiple combinations that have the same value if summed up. 
</br>
##### This is my version of the program: 
```
'''Use: keygen.py  [key_size] [number of keys] [optional -d]'''

import random
import sys


def key_generator(key):
    summed_value = 0
    for c in key:
        summed_value += ord(
            c)  # The ord() method returns an integer representing Unicode code point for the given Unicode character.
    return summed_value


def num_to_ascii():
    ascii_list = ""
    for i in range(92):
        ascii_list += chr(i + 33)
    return ascii_list


def main():
    key = ""
    key_size = 0
    quantity = 0
    bag_of_ascii = num_to_ascii()
    x = 0
    try:
        key_size = sys.argv[1]
        quantity = sys.argv[2]
    except Exception as e:
        if sys.argv[3] == "-d":
            print("Error: {}".format(e))
            exit(1)
        sys.stdout.write("Use: keygen.py [optional -d] [key_size] [number of keys]")
        exit(1)
    while x < int(quantity):
        for i in range(8):
            key += random.choice(bag_of_ascii)
        s = key_generator(key)
        if s > int(key_size):
            key = ""
        elif s == int(key_size):
            if sys.argv[3] == "-d":
                print("{}".format(key))
            else:
                sys.stdout.write(key)
                sys.stdout.flush()
            x += 1
            key = ""


main()


```
   
   
   
   ## 7/19/2018 Fuzzing
   
   ```
import random
import os
import hashlib

ORIG_FILE_NAME = "license_2"
ORIG_OUT = "origin_out"
PARAMETER = "AAAAAAAAAA"

FUZZ_FILE_NAME = "license_2_fuzzed"
FUZZ_OUT = "fuzz_out"

os.system("./license_2 {} > origin_out".format(PARAMETER))


def flip_it(stringy):
    element = random.randint(0, len(stringy) - 1)
    random_ascii_char = chr(random.randint(0, 255))
    in_bytes = bytes(random_ascii_char, "latin-1")
    return stringy[:element] + in_bytes + stringy[element + 1:]


def check_output():
    os.system("./{} {} > {}".format(FUZZ_FILE_NAME, PARAMETER, FUZZ_OUT))
    return md5_check(ORIG_OUT) == md5_check(FUZZ_OUT)


def md5_check(file):
    with open(file, 'rb') as fh:
        md5 = hashlib.md5()
        while True:
            data = fh.read(8129)
            if not data:
                break
            md5.update(data)
        return md5.hexdigest()


while True:
    try:
        with open(ORIG_FILE_NAME, "rb") as original_f, open(FUZZ_FILE_NAME, "wb") as fuzzed:
            os.system("chmod 777 license_2_fuzzed")
            fuzzed.write(flip_it(original_f.read()))
            fuzzed.close()
    except Exception as e:
        break

    if check_output() and md5_check(ORIG_FILE_NAME) != md5_check(FUZZ_FILE_NAME):
        print("{} - {}\nFound it".format(md5_check(ORIG_FILE_NAME),md5_check(FUZZ_FILE_NAME))
        break
    else:
        os.system("rm fuzz_out")
        os.system("rm license_2_fuzzed")
        continue
   
   
   ```
   
   
   
   
   
   
   
   
   
   
   
 ### Reference:
  -  [GDB Commands Reference](http://visualgdb.com/gdbreference/commands/)
      
